### 一、封装轮播图Carousel组件

​	一般看到的Carousel组件都为一个Carousel父组件包裹n个carousel-item组件。

```vue
<Carousel :height="180">
  <CarouselItem>1</CarouselItem>
  <CarouselItem>2</CarouselItem>
</Carousel>
```

​	一个carousel-item组件代表一个轮播项，要在Carousel组件传入内容就需要先声明一个默认插槽，供给使用者来声明轮播项列表，同时carousel-item组件也需要提供一个默认插槽来代表该轮播项里面的内容。

**1.过滤Carousel组件默认插槽的其他内容**

​	Carousel组件提供的默认插槽可以让使用者传入各式各样的DOM元素或组件，但是我们只以carousel-item组件为一个轮播项，所以需要过滤掉不需要渲染的内容，我们只需要接受carousel-item组件，其他内容都不需要渲染，所以需要获取到需要渲染的carousel-item组件列表。

​	defineSlots返回值为一个对象，对象中某个成员代表一个插槽，成员值为一个函数，调用即可获取到对应插槽里面的内容，这个内容其实是一个虚拟DOM，虚拟DOM是可以通过component组件来渲染的。

```ts
// Carousel组件的script部分

// 自定义属性
const props = defineProps<{ height: number }>()
// 定义插槽
const slots = defineSlots<{ default: () => any }>()
// 获取默认插槽的内容，以CarouselItem为一个轮播项，过滤出需要渲染的carouselItem组件列表，ele.type.name为组件的名称，我们只需要过滤出carouse-item组件实例即可，其他内容都不需要。
const defaultsList = slots.default().filter((ele: any) =>
  ele.type.name === "CarouselItem")

console.log(defaultsList)

defineOptions({
  name: 'Carousel'
})

```

**2.carousel-item组件的代码**

​	仅仅提供了一个默认插槽，供使用者传入轮播项的内容。

```vue
<template>
  <div class="carousel-item">
    <slot></slot>
  </div>
</template>

<script lang='ts' setup>
defineOptions({
  name:'CarouselItem'
})
</script>

<style scoped lang='scss'>
.carousel-item{

}
</style>
```

**3.渲染过滤出来的carousel-item组件列表**

​	由于插槽里面的内容默认情况下都是直接渲染出来的。但是我们只需要渲染carousel-item列表组件，所以我们可以在通过slot接受到插槽内容后，适用v-if禁止默认插槽的渲染。我们需要手动渲染接受到的插槽就可以使用我们的神**component 动态组件**，来实现手动渲染。过滤出来carousel-item组件列表之后，需要展示只需要v-for列表渲染component动态组件并传入对应的组件虚拟DOM即可完成手动渲染内容。

​	**不过下面这种过滤的方式不支持v-for指令渲染，指令渲染时需要额外进行处理。**

```vue
<template>
  <div class="carousel-container" :style="{ height: height + 'px' }">
    <slot v-if="false"></slot>
    <component v-for="( item, index ) in defaultsList" :key="index" :is="item" />
  </div>
</template>

<script lang='ts' setup>

// 自定义属性
const props = defineProps<{ height: number }>()
// 定义插槽
const slots = defineSlots<{ default: () => any }>()
// 获取默认插槽的内容，以CarouselItem为一个轮播项
const defaultsList = slots.default().filter((ele: any) =>
  ele.type.name === "CarouselItem")

console.log(defaultsList)

defineOptions({
  name: 'Carousel'
})
</script>

<style scoped lang='scss'>
.carousel-container {
  width: 100%;
}
</style>
```

​	由于通过v-for指令渲染时，会创建一个虚拟DOM，然后把列表渲染的内容作为该虚拟DOM的子孩子，此时就需要单独的进行判断了。

​	可以看到v-for渲染时，v-for的虚拟DOM实例的type为symbol，symbol可以转换成字符串，我们转换成字符串比对即可知晓本次渲染是通过模板渲染还是v-for指令渲染了，v-for指令渲染时，去查看他的子孩子列表，若子孩子虚拟DOM的名称为carousel-item，则保存即可。

**模板渲染时，插槽接受到的内容:**

![01](https://github.com/2sky2night/note-work/blob/master/img/01.png?raw=true)

**v-for指令渲染时，插槽接受到的内容：**

​	若使用了多个v-for指令，只会创建多个外层虚拟DOM，其子孩子就是对应渲染的列表。

![02](https://github.com/2sky2night/note-work/blob/master/img/02.png?raw=true)

![03](https://github.com/2sky2night/note-work/blob/master/img/03.png?raw=true)

**最后**

```vue
<template>
  <div class="carousel-container" :style="{ height: height + 'px' }">
    <div class="carousel-box" :style="{ left: `-${ currentIndex * 100 }%` }">
      <component v-for="( item, index ) in carouselList" :key="index" :is="item" />
    </div>
    <div class="dots-container">
      <CarouselDot v-model="currentIndex" :index="index" v-for="( item, index ) in carouselList" :key="index" />
    </div>
  </div>
  <slot v-if="false"></slot>
</template>

<script lang='ts' setup>
// 组件
import CarouselDot from './components/CarouselDot.vue'
// hooks
import { ref } from 'vue'

//当前显示的轮播图索引
const currentIndex = ref(0)
// 轮播图的自定义属性
const props = defineProps<{ height: number }>()
// 定义插槽
const slots = defineSlots<{ default: () => any }>()
// 获取默认插槽的内容
const defaultsList = slots.default()

const carouselList = defaultsList.reduce((list: any, ele: any) => {
  if (ele.type.name === 'CarouselItem') {
    // 若是模板渲染的子项且组件名称为CarouselItem就保留
    list.push(ele)
    return list
  } else if ((ele.type as Symbol).toString() === 'Symbol(v-fgt)') {
    // 若是通过v-for指令渲染的 则需要获取所有渲染的子内容并使用组件名是否为Carouselitme的筛选
    ele.children.filter((son: any) => son.type.name === 'CarouselItem').forEach((item: any) => list.push(item))
    return list
  }
}, [])

console.log('轮播项列表：', carouselList)

defineOptions({
  name: 'Carousel'
})

</script>

<style scoped lang='scss'>
.carousel-container {
  overflow: hidden;
  position: relative;

  .carousel-box {
    display: flex;
    position: absolute;
    left: 0;
    transition: .3s;
    width: 100%;
    height: 100%;
    z-index: 100;
  }

  .dots-container {
    position: absolute;
    width: 100%;
    display: flex;
    z-index: 101;
    bottom: 10px;
    justify-content: center;
  }

}
</style>
```

**4.不使用carousel-item组件渲染轮播图项**

​	也就是carousel组件默认插槽直接传入对应原生标签，以一个标签对应一个轮播项，只需要在carousel组件中进行处理即可。

**5.实现末尾两张的平滑切换**

​	依旧使用老套路，在列表的前面和后面加上最后一项和第一个轮播项，此时列表为n+2个，临界值为1和n。虽然有点bug，不过算了。

​	完成：

```vue
<template>
  <div class="carousel-container" :style="{ height: height + 'px' }">
    <div class="carousel-box" :style="{ left: `-${ currentIndex * 100 }%`, transition: `${ tsTime }s` }">

      <component :is="carouselList[ carouselList.length - 1 ]"></component>
      <component v-for="(        item, index        ) in carouselList" :key="index" :is="item" />
      <component :is="carouselList[ 0 ]"></component>

    </div>
    <div v-if="showDots" class="dots-container">
      <CarouselDot v-model="currentIndex" :index="item" v-for="            item             in carouselList.length"
        :key="item" />
    </div>
    <div class="carousel-btns" v-if="showBtns">
      <div class="carousel-btn" @click="throttlePre">&lt;</div>
      <div class="carousel-btn" @click="throttleNext">></div>
    </div>
  </div>
  <slot v-if="false"></slot>
</template>

<script lang='ts' setup>
// 组件
import CarouselDot from './components/CarouselDot.vue'
// hooks
import { ref, onMounted, nextTick, watch } from 'vue'
import throttle from '@/utils/tools/throttle'

//当前显示的轮播图索引
// 1--- carousel.length为轮播项的范围，0是追加到最前面的最后一项  carousel.length+1为追加到最后面的第一项
const currentIndex = ref(1)
// 轮播图的自定义属性
const props = defineProps<{
  /**
   * 高
   */
  height: number;
  /**
   * 是否显示指示器
   */
  showDots: boolean;
  /**
   * 是否显示上下轮播项按钮
   */
  showBtns: boolean;
  /**
   * 是否自动播放
   */
  autoplay: boolean;
  /**
   * 自动播放的延迟时间
   */
  delay: number;
}>()
// 定义插槽
const slots = defineSlots<{ default: () => any }>()
// 获取默认插槽的内容
const defaultsList = slots.default()
// 轮播图的过渡时间
const tsTime = ref<.3 | 0>(.3)
console.log(defaultsList)
// 要渲染的轮播项
const carouselList: any[] = defaultsList.reduce((list: any, ele: any) => {
  if (ele.type.name === 'CarouselItem') {
    // 若是模板渲染的子项且组件名称为CarouselItem就保留
    list.push(ele)
    return list
  } else if (typeof ele.type === "symbol" && ele.type.toString() === 'Symbol(v-fgt)') {
    // 若是通过v-for指令渲染的ele.type则是一个symbol类型 则需要获取所有渲染的子内容并使用组件名是否为Carouselitme的筛选
    ele.children.filter((son: any) => son.type.name === 'CarouselItem').forEach((item: any) => list.push(item))
    return list
  } else {
    // 若为其他内容则不需要渲染
    return list
  }
}, [])


// console.log('轮播项列表：', carouselList)

/**
 * 上一张
 */
function onHandlePre () {
  if (currentIndex.value == 1) {
    // 1为临界值 需要特殊处理
    // 先让其正常滑动到 0 也就是展示最后一项
    currentIndex.value--
    // 当页面更新后
    nextTick(() => {
      // 延迟300ms是因为轮播图动画是三秒 当动画执行完成时也就是移动到正常范围-1处了，也就是重复的最后一项。我们需要设置过渡时间为0，好让改变left时没有动画效果，然后立即移动到正常范围的最后一项。
      setTimeout(() => {
        tsTime.value = 0;
        currentIndex.value = carouselList.length
        // 当移动到最后一项后需要让过渡时间恢复 但是必须要用延迟器，而且必须要设置时间为动画效果的时间??(存疑)，否则也会被同步更新，会导致移动到正常范围的最后一项会出现动画效果。
        nextTick(() => {
          setTimeout(() => {
            tsTime.value = .3
          }, 150)
        })
      }, 300)

    })
  } else {
    currentIndex.value--
  }
}

/**
 * 下一张
 */
function onHandleNext () {
  if (currentIndex.value === carouselList.length) {
    // 若当前是正常范围的最后一项 需要另做处理
    currentIndex.value++
    nextTick(() => {
      // 调整过渡时间 立即跳转到正常范围中的第一项
      setTimeout(() => {
        tsTime.value = 0;
        currentIndex.value = 1;
        // 恢复过渡时间
        nextTick(() => {
          setTimeout(() => {
            tsTime.value = .3
          }, 150)
        })
      }, 300)
    })
  } else {
    currentIndex.value++
  }
}

const throttleNext = throttle(onHandleNext, 500)
const throttlePre = throttle(onHandlePre, 500)

// 是否自动播放？
if (props.autoplay) {
  onMounted(() => {
    setInterval(() => {
      throttleNext()
    }, props.delay)
  })
}


defineOptions({
  name: 'Carousel'
})

</script>

<style scoped lang='scss'>
.carousel-container {
  overflow: hidden;
  position: relative;

  .carousel-box {
    display: flex;
    position: absolute;
    left: 0;
    width: 100%;
    height: 100%;
    z-index: 100;
  }

  .dots-container {
    background-image: linear-gradient(to top, #0000002d, #00000000);
    position: absolute;
    width: 100%;
    display: flex;
    z-index: 102;
    bottom: 0px;
    height: 35px;
    align-items: center;
    justify-content: center;
  }

  .carousel-btns {
    pointer-events: none;
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    z-index: 101;
    display: flex;
    align-items: center;

    .carousel-btn {
      pointer-events: all;
      position: absolute;
      font-size: 18px;
      cursor: pointer;
      height: 25px;
      width: 25px;
      text-align: center;
      background-color: var(--dot-not-acitve-color);
      line-height: 25px;
      border-radius: 50%;
      color: #fff;
      transition: .3s;

      &:hover {
        background-color: var(--dot-acitve-color);

      }

      &:first-child {
        left: 10px;
      }

      &:last-child {
        right: 10px
      }
    }
  }

}
</style>
```

### 二、声明ref获取到的组件实例类型

​	有时候自己定义的组件，在使用时，通过ref想要获取到组件实例读取组件暴露出来的属性，但是想要定义组件实例的类型却不知道无从下手，就会导致ts推论错误。

​	其实组件实例的属性和你defineExpose时传入的参数是一样的，你暴露出了那些属性，在通过ref获取到组件实例时，组件实例上的属性和defineExpose传入的参数是一致的。

​	defineExpose也可以传入泛型达到编译时声明暴露的成员，所以只需要定义defineExpose的类型即可实现定义组件实例的类型。在外部使用时，引入该类型即可完成对ref类型的声明。

### 三、scss样式穿透

```scss
    ::v-deep .arco-btn{
      pointer-events: all;
    }
```

### 四、数据库并发解决方案

```ts
const Koa = require('koa');
const Router = require('koa-router');
const mysql = require('mysql2/promise');

const app = new Koa();
const router = new Router();

// 建立连接池
const pool = mysql.createPool({
  host: 'localhost',
  user: 'root',
  password: 'password',
  database: 'test',
  waitForConnections: true,
  connectionLimit: 10,
});

// 定义一个路由处理函数，该函数会开启一个事务，并更新一条数据，同时使用乐观锁进行并发控制
router.post('/update', async (ctx, next) => {
  const id = ctx.request.body.id;
  const newValue = ctx.request.body.newValue;

  // 开启事务
  const conn = await pool.getConnection();
  await conn.beginTransaction();

  try {
    // 查询当前数据的版本号和值
    const [rows, _] = await conn.query('SELECT value, version FROM mytable WHERE id = ? FOR UPDATE', [id]);

    if (!rows.length) {
      throw new Error(`Data with id=${id} does not exist`);
    }

    // 检查版本号是否匹配，若不匹配则表示数据已被修改过
    const { value, version } = rows[0];
    if (version !== ctx.request.body.version) {
      throw new Error(`Data with id=${id} has been modified by others`);
    }

    // 更新数据并增加版本号
    await conn.query('UPDATE mytable SET value = ?, version = version + 1 WHERE id = ?', [newValue, id]);

    // 提交事务
    await conn.commit();

    ctx.body = {
      success: true,
      message: `Data with id=${id} has been updated successfully`,
    };
  } catch (err) {
    // 回滚事务
    await conn.rollback();

    ctx.status = 500;
    ctx.body = {
      success: false,
      message: err.message,
    };
  } finally {
    // 释放数据库连接
    conn.release();
  }
});

app.use(router.routes()).use(router.allowedMethods());
app.listen(3000);

```

### 五、vue项目使用i18n插件

navigator.language这个BOM API可以获取当前浏览器的语言

#### 1.配置i18n插件

​	需要先安装vue-i18n插件，创建locale文件夹，创建index文件，引入后配置i18n插件，同时需要准备各个国家的翻译文案。导出i18n对象后，可以直接使用app.use注册插件，就可以在模板中使用该插件提供的api实现多语言文本替换了。

```ts
import { createI18n } from 'vue-i18n';
// 提前准备好的各个国家的翻译文案
import CN from './CN';
import US from './US';
import BR from './BR';
import ID from './ID';
import JP from './JP';
import RU from './RU';
import TH from './TH';
import VN from './VN';
import NG from './NG';

const i18n = createI18n({ 
    // 当前激活的国家文本 （value必须是messages配置项中的某个key）
    locale: 'CN', 
    // 失败激活的国家文本（value必须是messages配置项中的某个key）
    fallbackLocale: 'US',
    allowComposition: true,
    // 配置各个国家的文本
    messages: {
        CN,
        US,
        BR,
        ID,
        JP,
        RU,
        TH,
        VN,
        NG
    }
});
  
export default i18n;
```

#### 2.配置某个国家的文案

​	形如这种对象形式的来配置各个文本

// CN.ts

```ts
import layout from './CN/layout'
export default {
  layout,
  message: {
    hello:'你好'
  }
}
```

// 模块化举例 layout.ts

```ts
export default {
  header: {
    signIn: '登录',
    signUp: '注册',
    home: '首页',
    game:'游戏'
  },
}
```

#### 3.在模板中使用

​	通过app.use安装好了该插件就可以直接在模板中使用其提供的$t方法，来通过2中配置的对象路径来读取对应的文案。

```vue
<template>
  <div class="sign-container">
    <div class="mr-10 sign-in-btn btn">{{ $t('layout.header.signIn') }}</div>
    <div class="sign-up-btn btn">{{ $t('layout.header.signUp') }}</div>
  </div>
</template>
```

#### 4.在ts中使用

 	引入创建的i18n实例即可使用提供的api，i18n.global.t()，读取对象路径获取对应的值。

 ```ts
<script lang='ts' setup>
import NavBtn from '@/components/btn/NavBtn.vue';
import i18n from '@/locale' // 引入i8n实例

const list = [
  { icon: 'icon-home', title: i18n.global.t('layout.header.home'), path: '/' },
  { icon: 'icon-live-broadcast', title: i18n.global.t('layout.header.game'), path: '/game' },
]
</script>
 ```

#### 5.切换当前语言设置

​	该钩子可以获取到i18n实例，i18n.locale.value即可设置语言，但是必须是实例化i18n时messages配置项中有的key才能生效。

```ts
import { useI18n } from 'vue-i18n'
// i18n插件
const i18n = useI18n()
function setLanguage (value: LOCALE_VALUE_TYPE) {
  i18n.locale.value = value
}
```

​	所有模板内容调用了$t函数都会重新解析模板生成对应语言的dom文本

![01](https://github.com/2sky2night/note-work/blob/master/img/05.png?raw=true)

​	**但是通过ts调用t函数是不会因为语言更新而重新调用 这个需要特别注意（也就是4的例子）。**，这种方式生成的内容都是死内容，需要自己手动监听语言的变化，重新调用t函数生成对应语言文本。

![01](https://github.com/2sky2night/note-work/blob/master/img/04.png?raw=true)

#### 6.(JS中如何处理多语言切换)多语言路由表渲染导航菜单处理

​	最开始我是直接在路由上直接调用t函数根据语言模式生成对应文本，这样生成的路由表是文本内容是死的，有两种解决方案

###### 1.getter函数（代码量多一些）

​	所以可以配置一个getter函数，getter函数调用后返回当前语言的路由表。

###### routes.ts

```ts
import type { RouteRecordRaw } from 'vue-router';
import i18n from '@/locale';

export const initRoutes: RouteRecordRaw[] = [
  {
    path: '/',
    name: 'home',
    component: () => import('@/views/home/index.vue'),
    meta: {
      title: i18n.global.t('menu.home'),
      icon: 'icon-folder',
      level: 1
    }
  },
  {
    path: '/sports',
    name: 'sports',
    component: () => import('@/views/sports/index.vue'),
    meta: {
      title: i18n.global.t('menu.sports'),
      icon: 'icon-at',
      level: 1
    }
  },
  {
    path: '/game',
    name: 'game',
    component: () => import('@/views/game/index.vue'),
    meta: {
      title: i18n.global.t('menu.game'),
      icon: 'icon-code',
      level: 1
    }
  },
  {
    path: '/test',
    name: 'test',
    component: () => import('@/views/test/index.vue'),
    meta: {
      title: 'test',
      icon: 'icon-folder',
      level: 1
    },
    children: [
      {
        path: '/test/test-son-01',
        name: 'test-son-01',
        component: () => import('@/views/test/children/test-son-01/index.vue'),
        meta: {
          title: 'test-son-01',
          icon: 'icon-folder',
          level: 2
        },
        children: [
          {
            path: '/test/test-son-01/test-son-01-son-01',
            name: 'test-son-01-son-01',
            component: () => import('@/views/test/children/test-son-01/children/test-son-01-son-01/index.vue'),
            meta: {
              title: 'test-son-01-son-01',
              icon: 'icon-folder',
              level: 3
            },
          },
          {
            path: '/test/test-son-01/test-son-01-son-02',
            name: 'test-son-01-son-02',
            component: () => import('@/views/test/children/test-son-01/children/test-son-01-son-02/index.vue'),
            meta: {
              title: 'test-son-01-son-02',
              icon: 'icon-folder',
              level: 3
            },
          },
        ]
      },
      {
        path: '/test/test-son-02',
        name: 'test-son-02',
        component: () => import('@/views/test/children/test-son-02/index.vue'),
        meta: {
          title: 'test-son-02',
          icon: 'icon-folder',
          level: 2
        },
        children: [
          {
            
            path: '/test/test-son-02/test-son-02-son-01',
            name: 'test-son-02-son-01',
            component: () => import('@/views/test/children/test-son-02/children/test-son-02-son-01/index.vue'),
            meta: {
              title: 'test-son-02-son-01',
              icon: 'icon-folder',
              level: 3
            },
          },
          {
            path: '/test/test-son-02/test-son-02-son-02',
            name: 'test-son-02-son-02',
            component: () => import('@/views/test/children/test-son-02/children/test-son-02-son-02/index.vue'),
            meta: {
              title: 'test-son-02-son-02',
              icon: 'icon-folder',
              level: 3
            },
          },
        ]
      }
    ]
  },
  {
    path: '/blog',
    name: 'blog',
    component: () => import('@/views/blog/index.vue'),
    meta: {
      title: i18n.global.t('menu.blog'),
      icon: 'icon-launch',
      level: 1
    }
  },
]

/**
 * 获取路由表
 * @returns 
 */
export const getterInitRoutes = () => {
  return [
    {
      path: '/',
      name: 'home',
      component: () => import('@/views/home/index.vue'),
      meta: {
        title: i18n.global.t('menu.home'),
        icon: 'icon-folder',
        level: 1
      }
    },
    {
      path: '/sports',
      name: 'sports',
      component: () => import('@/views/sports/index.vue'),
      meta: {
        title: i18n.global.t('menu.sports'),
        icon: 'icon-at',
        level: 1
      }
    },
    {
      path: '/game',
      name: 'game',
      component: () => import('@/views/game/index.vue'),
      meta: {
        title: i18n.global.t('menu.game'),
        icon: 'icon-code',
        level: 1
      }
    },
    {
      path: '/test',
      name: 'test',
      component: () => import('@/views/test/index.vue'),
      meta: {
        title: 'test',
        icon: 'icon-folder',
        level: 1
      },
      children: [
        {
          path: '/test/test-son-01',
          name: 'test-son-01',
          component: () => import('@/views/test/children/test-son-01/index.vue'),
          meta: {
            title: 'test-son-01',
            icon: 'icon-folder',
            level: 2
          },
          children: [
            {
              path: '/test/test-son-01/test-son-01-son-01',
              name: 'test-son-01-son-01',
              component: () => import('@/views/test/children/test-son-01/children/test-son-01-son-01/index.vue'),
              meta: {
                title: 'test-son-01-son-01',
                icon: 'icon-folder',
                level: 3
              },
            },
            {
              path: '/test/test-son-01/test-son-01-son-02',
              name: 'test-son-01-son-02',
              component: () => import('@/views/test/children/test-son-01/children/test-son-01-son-02/index.vue'),
              meta: {
                title: 'test-son-01-son-02',
                icon: 'icon-folder',
                level: 3
              },
            },
          ]
        },
        {
          path: '/test/test-son-02',
          name: 'test-son-02',
          component: () => import('@/views/test/children/test-son-02/index.vue'),
          meta: {
            title: 'test-son-02',
            icon: 'icon-folder',
            level: 2
          },
          children: [
            {
              
              path: '/test/test-son-02/test-son-02-son-01',
              name: 'test-son-02-son-01',
              component: () => import('@/views/test/children/test-son-02/children/test-son-02-son-01/index.vue'),
              meta: {
                title: 'test-son-02-son-01',
                icon: 'icon-folder',
                level: 3
              },
            },
            {
              path: '/test/test-son-02/test-son-02-son-02',
              name: 'test-son-02-son-02',
              component: () => import('@/views/test/children/test-son-02/children/test-son-02-son-02/index.vue'),
              meta: {
                title: 'test-son-02-son-02',
                icon: 'icon-folder',
                level: 3
              },
            },
          ]
        }
      ]
    },
    {
      path: '/blog',
      name: 'blog',
      component: () => import('@/views/blog/index.vue'),
      meta: {
        title: i18n.global.t('menu.blog'),
        icon: 'icon-launch',
        level: 1
      }
    },
  ]
}
```

###### 使用

```vue
<template>
  <div class="navigations-container">
    <a-menu :selected-keys="[ $route.path ]">
      <NavigateItems :routes="routesList" />
    </a-menu>
  </div>
</template>

<script lang='ts' setup>
// 路由表
import { getterInitRoutes } from '@/router/routes';
// 组件
import NavigateItems from './NavigateItems.vue';
// hooks
import { useRoute } from 'vue-router';
import useSettingStore from '@/store/setting';
import { watch,reactive } from 'vue';
import { storeToRefs } from 'pinia';
// types
import type { RouteRecordRaw } from 'vue-router';

// 设置仓库
const settingStore = useSettingStore()
// 当前语言
const { language } = storeToRefs(settingStore)
// 路由
const $route = useRoute()
// 路由表
const routesList: RouteRecordRaw[] = reactive([])

// 语言变化时 需要重新根据语言来获取最新的路由表
watch(language, () => {
  routesList.length = 0
  getterInitRoutes().forEach(ele => {
    routesList.push(ele)
  })
},{immediate:true})

</script>

<style scoped lang='scss'>
.navigations-container {
  flex-grow: 1;
}
</style>
```

##### 2.使用computed函数

​	利用i18n.global.t函数在语言切换时会重新调用一次的特性，可以使用computed函数，传入getter函数，getter函数直接返回路由表，这样就能做到语言切换时重新调用getter函数，相当于底层就是基于1的实现，但是简化了监听的流程，让vue监听到t函数执行直接调用getter函数获取最新的路由表。

定义

```ts
/**
 * 获取路由表
 * @returns 
 */
export const getterInitRoutes = computed(() => {
  return [
    {
      path: '/',
      name: 'home',
      component: () => import('@/views/home/index.vue'),
      meta: {
        title: i18n.global.t('menu.home'),
        icon: 'icon-folder',
        level: 1
      }
    },
    {
      path: '/sports',
      name: 'sports',
      component: () => import('@/views/sports/index.vue'),
      meta: {
        title: i18n.global.t('menu.sports'),
        icon: 'icon-at',
        level: 1
      }
    },
    {
      path: '/game',
      name: 'game',
      component: () => import('@/views/game/index.vue'),
      meta: {
        title: i18n.global.t('menu.game'),
        icon: 'icon-code',
        level: 1
      }
    },
    {
      path: '/test',
      name: 'test',
      component: () => import('@/views/test/index.vue'),
      meta: {
        title: 'test',
        icon: 'icon-folder',
        level: 1
      },
      children: [
        {
          path: '/test/test-son-01',
          name: 'test-son-01',
          component: () => import('@/views/test/children/test-son-01/index.vue'),
          meta: {
            title: 'test-son-01',
            icon: 'icon-folder',
            level: 2
          },
          children: [
            {
              path: '/test/test-son-01/test-son-01-son-01',
              name: 'test-son-01-son-01',
              component: () => import('@/views/test/children/test-son-01/children/test-son-01-son-01/index.vue'),
              meta: {
                title: 'test-son-01-son-01',
                icon: 'icon-folder',
                level: 3
              },
            },
            {
              path: '/test/test-son-01/test-son-01-son-02',
              name: 'test-son-01-son-02',
              component: () => import('@/views/test/children/test-son-01/children/test-son-01-son-02/index.vue'),
              meta: {
                title: 'test-son-01-son-02',
                icon: 'icon-folder',
                level: 3
              },
            },
          ]
        },
        {
          path: '/test/test-son-02',
          name: 'test-son-02',
          component: () => import('@/views/test/children/test-son-02/index.vue'),
          meta: {
            title: 'test-son-02',
            icon: 'icon-folder',
            level: 2
          },
          children: [
            {
              
              path: '/test/test-son-02/test-son-02-son-01',
              name: 'test-son-02-son-01',
              component: () => import('@/views/test/children/test-son-02/children/test-son-02-son-01/index.vue'),
              meta: {
                title: 'test-son-02-son-01',
                icon: 'icon-folder',
                level: 3
              },
            },
            {
              path: '/test/test-son-02/test-son-02-son-02',
              name: 'test-son-02-son-02',
              component: () => import('@/views/test/children/test-son-02/children/test-son-02-son-02/index.vue'),
              meta: {
                title: 'test-son-02-son-02',
                icon: 'icon-folder',
                level: 3
              },
            },
          ]
        }
      ]
    },
    {
      path: '/blog',
      name: 'blog',
      component: () => import('@/views/blog/index.vue'),
      meta: {
        title: i18n.global.t('menu.blog'),
        icon: 'icon-launch',
        level: 1
      }
    },
  ]
})
```

使用

```ts
<template>
  <div class="navigations-container">
    <a-menu :selected-keys="[ $route.path ]">
      <NavigateItems :routes="getterInitRoutes" />
    </a-menu>
  </div>
</template>

<script lang='ts' setup>
// 路由表
import { getterInitRoutes } from '@/router/routes';
// 组件
import NavigateItems from './NavigateItems.vue';
// hooks
import { useRoute } from 'vue-router';
// 路由
const $route = useRoute()

</script>

<style scoped lang='scss'>
.navigations-container {
  flex-grow: 1;
}
</style>
```

#### 7.渲染动态内容

​	例如要渲染 确定删除xx吗？的国际化

定义：

```ts
en:{
    deleteTip:'Are you sure to delete {username}'
},
cn:{
    deleteTip:'你确定要删除 {username} 吗'
}
```

使用

```ts
$t('deleteTip',{username:'张三'})
```

8.多语言面包屑

```ts
<template>
  <div class="breadcrumb-container">
    <a-breadcrumb>
      <a-breadcrumb-item @click="() => onHandleClick(item.path)" v-for="item in list" :key="item.path">
        {{ item.title }}
      </a-breadcrumb-item>
    </a-breadcrumb>
  </div>
</template>

<script lang='ts' setup>
import { useRoute, useRouter } from 'vue-router';
import { computed } from 'vue'
import type { RouteRecordRaw } from 'vue-router';
import { getterInitRoutes } from '@/router/routes';

const router = useRouter()
const route = useRoute()
const list = computed(() => {
  // 当前激活的路由
  const nowRoutes = route.matched
  // 遍历当前激活的路由表 获取对应的title
  return nowRoutes.map(ele => {
    return {
      path: ele.path,
      title:getRouteTitle(ele.path,getterInitRoutes.value)
    }
  })
})

// 根据当前路由的path获取对应的title
function getRouteTitle (path: string, routes: RouteRecordRaw[]):string {
  let title = ''
  // 遍历当前层级的路由 获取对应的title
  if(routes.some(ele => {
    if (ele.path === path) {
      if (ele.meta) {
        title = ele.meta.title
      } else {
        title = ele.path
      }
      return true
    }
  })) {
    // 若找到了则直接返回对应title
    return title
  } else {

    // 若没找到就遍历当前层的每一级路由，递归调用对应子路由
    for (let i = 0; i < routes.length; i++){
      // 若有子孩子就递归调用 没有就跳过调用递归函数
      if (routes[ i ].children) {
        const res = getRouteTitle(path, routes[ i ].children as RouteRecordRaw[])
        // 若找到了 并且不为not found（因为第一次调用可能未找到则返回值为not found，但后续子路由还没开始找呢） 没找到则直接跳过，遍历下一个路由
        if (res&&res!=='not found') {
          return res
        }
      }
    }

    // 兜底的 若遍历一直没找到就是not found
    return 'not found'
  }
}

const onHandleClick = (path: string) => {
  router.push(path)
}

defineOptions({
  name: 'Breadcrumbs'
})
</script>

```

六、模态框

```vue
<template>
  <Teleport to="body">
    <Transition name="modal">
      <div class="modal-container" v-if="isShowModal" @click="handleCloseModal">
        <Transition name="content" appear>
          <div @click.stop="" class="content" v-if="isShow">
            <slot name="default"></slot>
          </div>
        </Transition>
      </div>
    </Transition>
  </Teleport>
</template>

<script lang='ts' setup>
import { ref, watch, nextTick } from 'vue';

const props = defineProps<{
  /**
   * 模态框是否显示
   */
  modelValue: boolean
}>()
const emit = defineEmits<{
  /**
   * 
   */
  'update:modelValue': [ value: boolean ]
  /**
   * 模态框关闭的事件
   */
  'close': []
}>()
defineSlots<{
  default: () => any
}>()

// 是否显示主要内容
const isShow = ref(true)
const isShowModal = ref(false)
// 当前是否还在执行关闭的动画效果？
let time: null | number = null

/**
 * 点击遮罩层的回调
 */
const handleCloseModal = () => {
  isShow.value = false;
  // 动画效果执行完毕时 销毁模态框
  nextTick(() => {
    time=setTimeout(() => {
      isShowModal.value = false
      emit('update:modelValue', false)
      emit('close')
      time=null
    }, 300)
  })
}

// 保持一致
watch(() => props.modelValue, (v) => {
  if (time) {
    // 非常重要
    // 若当前还有在挂起的延时器 则关闭延时器 避免数据源混乱
    clearTimeout(time)
  }
  if (!v) {
    // 关闭模态框
    handleCloseModal()
  } else {
    isShowModal.value = v
    isShow.value = v
  }
}, { immediate: true })
defineOptions({ name: 'Modal' })
</script>

<style scoped lang='scss'>
.modal-container {
  position: fixed;
  z-index: 999;
  top: 0;
  right: 0;
  bottom: 0;
  left: 0;
  background-color: var(--color-mask-bg);
  display: flex;
  align-items: center;
  justify-content: center;

  .content {
    background-color: var(--color-bg-1);
    min-height: 100px;
    min-width: 100px;
  }

  .content-enter-active {
    animation: contentMove .3s 1 ease-in-out;
  }

  .content-leave-active {
    animation: contentMove .3s 1 ease-in-out reverse;
  }

  @keyframes contentMove {
    from {
      opacity: 0;
      transform: scale(.7);
    }

    to {
      opacity: 1;
      transform: none;
    }
  }
}
</style>
```


### 六、 vue+tsx

https://juejin.cn/post/7151950058501373989
安装
```shell
pnpm add @vitejs/plugin-vue-jsx -D
```
安装完成后在vite配置文件中安装插件

```js
import vueJsx from "@vitejs/plugin-vue-jsx";

export default defineConfig({
  plugins: [
    vueJsx(),
  ]
})

```


### 七、全局组件的ts类型提示

https://blog.csdn.net/weixin_43972992/article/details/124755426 
[全局组件类型声明的最佳实践 (Vue3+TS+Volar) - 掘金 (juejin.cn)](https://juejin.cn/post/7066730414626308103)

### 八、封装鉴权按钮组件

​	页面中有很多按钮都需要用户登录才能使用的，如果给每个按钮的点击事件添加判断登录的逻辑多少有点繁琐，所以就想自己封装一个鉴权组件（最开始想用自定义指令实现的，奈何自定义指令没办法捕获点击事件）。

​	原理：鉴权按钮组件其实没有按钮，通过slots传入对应的按钮组件，外层一个div容器，当点击插槽中的内容时，事件触发会从html根元素开始捕获，会经过外层的div，最后到达插槽里面的元素，我们可以通过事件捕获机制来拦截到此次点击事件，并执行对应鉴权逻辑，最后（最关键的是）通过stopImmediatePropagation，停止事件捕获，也就是说停止浏览器向里面寻找事件触发的元素，和停止事件冒泡一个逻辑，只是方向不一样，冒泡是从里到外，捕获是从外到内。

```vue
<template>
  <div @click.capture="(e)=>onHandleClick(e)" class="auth-btn-container">
    <slot name="default"></slot>
  </div>
</template>

<script lang='ts' setup>
// hooks
import useUserStore from '@/store/user';
import { useMessage } from 'naive-ui';
// types
import type { VNode } from 'vue';
// configs
import tips from '@/config/tips';

const message = useMessage()
const userStore = useUserStore()

/**
 * 点击的该容器的回调 在捕获时触发
 */
const onHandleClick =  (e:Event) => {
  if (userStore.isLogin) {
    message.success('用户登录了')
  } else {
    message.warning('未登录')
    // 停止事件捕获 阻止继续事件捕获
    e.stopImmediatePropagation()
  }
}

defineSlots<{
  default:()=>VNode[]
}>()
</script>
```



### 九、路由模式

浏览器的路由模式有两种:history和hash模式，他们的表现形式都是在url呈现的，只不过hash模式以hash值表述，history模式以模拟路径表示，他们两个相同点都是值发生变化时都不会导致http请求，比较大的不同点是第一次加载页面时，会发生一次网络请求加载html资源，但是hash值不会被后端接受到，而history模式下对应的模拟路径也会被当成请求的路径，从而会导致不能正确的加载html资源

一个URL信息可以从location对象可以看出，如`(http://127.0.0.1:3001/sadasd?op=8#/dsad)`会被解析成:

host:'127.0.0.1:3001' 主机名

pathname:'/sadasd'

port:'3001'

hash:'#/dasd'

protocol:'http:',

search:'?op=8'

....

hash模式

​	hash模式的原理就是通过监听，url上的hash值变化，根据当前hash值与路由表进行匹配，从而渲染对应内容。如何监听hash值的变化呢？使用onhashchange即可监听浏览器hash值变化了，hash值变化从之执行相关操作即可。

```js
	// 路由表
    const routes = [
      {
        path: '/home',
        template: '<h1>this is home</h1>'
      },
      {
        path: '/user',
        template: '<div>this is user</div>'
      }
    ]
        // hash值变化时
    window.onhashchange = (ev) => {
      // ev为一个事件对象，包含了新旧的url值等等
      const path = ev.newURL.split('#')[ 1 ]
      // 解析出路由路径后，进入路由表进行匹配，渲染对应内容
      routes.some(ele=>{
          if(ele.path===path){
              body.innerHTML=ele.template
              return true
          }
      })
    }
```

history模式

​	history模式主要是使用pushState、replaceState这两个API实现url上pathname的变化，而popState做为window上的事件监听，可以监听浏览器前进或后退，从而执行渲染对应内容。

API

​	history.pushState(state,title,path)

​	第一个参数可以作为路由传参的方式来保存数据？

​	第二个是浏览器标题，一般传入空串即可，大部分浏览器会忽略该参数

​	第三个是path路径，调用后url的pathname就会变成对应的path值。

```ts
 history.pushState({}, "", "home")
```

调用后url上的pathname就会变成第三个参数的值，然后就可以根据pathname来匹配路由，从而渲染对应路由视图，**注意调用pushState或replaceState都不会触发popstate事件。**

事件popState

​	popState会在浏览器前进后退时会触发，函数可以接受到一个事件对象，里面有对应pushState时传入的state，事件触发后可以根据当前pathname匹配路由表来渲染对应路由

### 十、文件切片简易版

#### 1.后端实现
文件切片上传，总体思路：
  1.把收到的某个切片文件存放在一个切片文件夹中（该文件夹唯一标识一个文件）
  2.将目标切片文件夹中的所有切片合并成一个文件，删除所有切片和对应切片文件夹即可
后端实现需要接触到许多fs模块的内容，许多API都是一知半解，能用就行那种程度

##### 文件切片上传
  文件切片上传，通过文件名称创建切片文件夹，将后续请求所有的切片文件都写入到该文件夹中。
  约定好form-data中的字段名为(实际情况按照开发需求定，下列情况中，文件名称和解析方式都具有特殊性)：
  **fileName**:文件名称，不包括扩展名，用来创建切片文件夹名称(文件名不能出现如：.或_，会影响解析和创建文件)
  **chunkName**:切片的名称，形如 xxx.png_0,xxx为文件名称，png为文件扩展名，_0为文件切片时的索引，后端需要通过索引号按顺序合并成文件，才能正确的访问文件
  **chunkFile**:切片文件，用来保存到切片文件夹中。
  需要解析请求体里面的form-data中的各个对象，我们使用@koa/multer来解析form-data中的数据:
  ```ts
router.post(
  '/file-chunk',
  // 解析请求体中的字段（文件字段必须声明，非文件字段可声明可不声明）
  upload.fields(
    [
      {
        // 分片名（分片名称的格式 xxx.png_0）
        name: 'chunk-name'
      },
      {
        // 分片文件
        name: 'chunk',
        maxCount: 1
      },
      {
        // 文件名称
        name: 'file-name'
      }
    ]
  ),
  ()=>{
    // 中间件部分
  }
)

  ```
  通过中间件我们获取到解析成功后的请求体，用fileName来创建文件夹，创建之前需要先检查文件夹是否存在，若存在则直接将切片文件保存到文件夹中，没有需要创建后，再存放到切片文件夹中。
  fs.mkdir创建文件夹
  fs.existsSync查询文件夹是否存在
  fs.writeFile来将切片文件保存到对应切片文件夹中
  中间件实现：
  ```ts
// 文件分片上传
// 使用@koa/multer可以自动配置上传form-data时的字段名，从而进行解析
// 非文件字段会被保存到ctx.request.body中
// 文件字段会被保存到ctx.request.files中
router.post(
  '/file-chunk',
  // 解析请求体中的字段（文件字段必须声明，非文件字段可声明可不声明）
  upload.fields(
    [
      {
        // 分片名（分片名称的格式 xxx.png_0）
        name: 'chunk-name'
      },
      {
        // 分片文件
        name: 'chunk',
        maxCount: 1
      },
      {
        // 文件名称
        name: 'file-name'
      }
    ]
  ),
  (ctx) => {
    // 非文件的form-data字段会被解析到body里
    // console.log(ctx.request.body);
    // 文件会被保存到ctx.request.files中
    // console.log(ctx.request.files);

    // 1.解析form-data中的数据
    // @ts-ignore 获取文件列表
    const fileList: any = ctx.request.files
    // 解析分片文件
    const file = fileList[ 'chunk' ][ 0 ]
    // 解析出分片文件的文件名称
    const chunkName = ctx.request.body[ 'chunk-name' ]
    // 解析出文件的名称(以文件的名称来创建文件夹)
    const fileName = ctx.request.body[ 'file-name' ]

    // 2.创建文件夹，用于存放分片文件（根据文件名称来创建文件夹，将所有分片文件保存到文件夹中）
    // 文件夹路径
    const chunkDirPath = path.resolve('./static/chunk', `./${ fileName }`)
    if (!fs.existsSync(chunkDirPath)) {
      // 文件不存在 创建文件夹
      fs.mkdirSync(chunkDirPath)
    }
    // 3.将当前分片文件保存在分片文件夹中
    const chunkFilePath = path.resolve(chunkDirPath, `./${ chunkName }`)
    // 将文件保存到分片文件夹中
    try {
      fs.writeFileSync(chunkFilePath, file.buffer)
      ctx.body = {
        msg: 'save ok',
        fileName,
        chunkName
      }
    } catch (error) {
      console.log(error);
      ctx.body = {
        msg: 'save fail',
        fileName,
        chunkName
      }
    }
  }
)
  ```


#### 将切片文件合并
  切片合并，约定：需要传入合并的文件夹名称与切片时每一份数据的大小，再读取切片文件夹，遍历所有切片文件，将切片文件写入到合并文件中，最后删除切片文件。

  查询参数：
  **fileName**:通过fileName来找到需要合并的切片文件夹(本地中切片文件夹目录必须存在该文件夹)
  **size**:解析每份切片文件的大小，在合并文件时需要按照字节顺序依次写入内容。

  先通过fileName到切片文件目录中查询是否存在该文件夹，存在则拼接出路径，读取该文件夹中所有的切片文件名称，并通过索引顺序来排序。
  在对应目录下通过文件流的方式创建合并文件，遍历排序切片文件名称数组，将切片名称拼接成路径通过文件流的方式读取文件，按照字节顺序写入到合并文件中。
  fs.readdirSync读取文件夹中的所有文件名称
  fs.createReadStream创建读文件流
  fs.createWriteStream创建写文件流，可以指定从那个字节大小创建可写文件流
  streamIns01.pipe(streamIns02)将实例01的文件流写入到实例02文件流中

  ```ts
// 合并切片的文件文件
router.get('/merge-file', async (ctx) => {
  // 解析需要解析的文件名称
  if (ctx.query.fileName === undefined || ctx.query.size === undefined) {
    return ctx.body = 'fileName or size is query need!'
  }
  // 文件名称
  const fileName = ctx.query.fileName as string
  // 分片大小为多少？
  const size = +ctx.query.size

  const res = await resolveMerge(fileName, size)

  if (res === 0) {
    ctx.body = 'file not exist!'
  } else {
    ctx.body = res
  }

})

async function resolveMerge (fileName: string, size: number) {
  // 切片文件夹的路径（一个文件夹代表一个文件）
  const chunkDirPath = path.resolve('./static/chunk', `./${ fileName }`)
  // 1.查询文件是否存在
  if (!fs.existsSync(chunkDirPath)) {
    // 文件不存在
    return Promise.resolve(0)
  }
  // 文件存在
  // 2.读取该切片文件夹中的所有文件名称
  const fileNameList = fs.readdirSync(chunkDirPath)
  // @ts-ignore 切片名称为 xxx.png_0 需要按照索引顺序进行排序，避免文件被混乱的合并
  fileNameList.sort((a, b) => a.split('_')[ 1 ] - b.split('_')[ 1 ])

  // 3.遍历所有切片合并文件，并删除切片文件夹
  const res = fileNameList.map((chunkName, index) => {
    // 当前切片的路径
    const chunkFilePath = path.resolve(chunkDirPath, `./${ chunkName }`)
    // 需要合并的文件路径(合并后文件的路径)
    const filePath = path.resolve('./static/file', `${ chunkName.split('_')[ 0 ] }`)

    // 根据当前切片的路径，访问该切片，将该切片写入到目标文件中
    return pipeStream(
      chunkFilePath,
      // 根据size的指定位置创建可写流
      fs.createWriteStream(filePath, {
        start: index * size
      })
    )
  })
  // 等待全部切片写入完成
  await Promise.all(res)
  // 全部切片写入完成后，就删除该切片文件夹
  fs.rmdirSync(chunkDirPath)

  return Promise.resolve({
    fileName,
    filePath: 'http://127.0.0.1:3000/file' + '/' + fileNameList[ 0 ].split('_')[ 0 ]
  })
}

// 写入文件流
function pipeStream (chunkPath: string, writeStream: fs.WriteStream) {
  return new Promise<void>(r => {
    // 读取切片流
    const readStream = fs.createReadStream(chunkPath)
    // 读取完成就删除该切片
    readStream.on("end", () => {
      fs.unlinkSync(chunkPath)
      r()
    })
    // 将切片流写入到目标文件流中
    readStream.pipe(writeStream)
  })
}

  ```

上述只是实现了切片文件并合并的一种方式，写得很特殊，没法考虑到解析时文件名和扩展名的问题，只是提供一种思路。
不论是createReadStream和createWriteStream都可以指定从那个字节开始读取/写入数据，也可以指定end，表示读取/写入到对应字节结束。

### 十一、Vue命令式组件实践

​	以往封装的命令式组件往往都是通过h和render，临时渲染的组件，并且文件拆分成了几个（函数文件、组件文件、样式文件），非常零散。

​	这一次可以通过jsx+css-in-js（@styils/vue）实现一个文件即可完成命令式组件的封装
 @styils/vue： https://styils.github.io/styils/
```tsx

import { Component, createApp } from "vue";
import "./index.css"; //这个只是真实DOM的样式，其实也可以不使用，将其封装成组件也可以。
// css-in-js的vue插件
import { styled } from "@styils/vue";

// 配置了样式的组件元素
// styled会创建一个组件，在传入参数时可以选择组件的tagName和对应样式，并且最终渲染时会通过class选择器给元素配置样式的。
// 消息容器
const BoxContainer = styled("div", {
  backgroundColor: "#fff",
  borderRadius: "5px",
  height: "150px",
  width: "80%",
  maxWidth: "500px",
  padding: "10px",
  boxSizing: "border-box",
});
// 按钮
const ConfirmButton = styled("button", {
  border: "none",
  padding: "5px 10px",
  backgroundColor: "skyblue",
  color: "#fff",
  cursor:'pointer'
});

// 组件配置项
const MessageBox: Component = {
  // 自定义熟悉
  props: {
    title: {
      type: String,
      required: true,
    },
  },
 // 定义的方法
  methods: {
    onHandleClick() {
      this.$emit("toClose");
    },
  },
  // 自定义事件
  emits: ["toClose"],
  // 组件的render函数
  render(ctx: any) {
    return (
      <BoxContainer>
        <div class="content">{ctx.title}</div>
        <ConfirmButton onClick={ctx.onHandleClick}>确认</ConfirmButton>
      </BoxContainer>
    );
  },
};

// 创建消息盒子的函数
export default function (title: string) {
  const container = document.createElement("div");
  container.classList.add("message_box_mask_container");
  const app = createApp(MessageBox, {
    title,
    onToClose: () => {
      app.unmount();
      container.remove();
    },
  });
  app.mount(container);
  document.body.appendChild(container);
}


```


### 十二、指令式预览元素（元素共享效果）
#### 效果
  通过封装的指令，让目标元素拥有预览的效果（且过渡动画算元素共享效果？），点击目标元素展示预览效果并隐藏目标元素，点击遮罩层或滚动、拉伸事件取消预览。
  需要用到Node.clone这个API来克隆元素,注意：`克隆一个元素节点会拷贝它所有的属性以及属性值，当然也就包括了属性上绑定的事件 (比如onclick="alert(1)"),但不会拷贝那些使用addEventListener()方法或者node.onclick = fn这种用 JavaScript 动态绑定的事件。`
#### 实现原理
##### 基本实现
  1.克隆（深克隆，可以克隆后代元素）目标元素
  2.创建遮罩层容器，让克隆元素添加到里面成为子元素
  3.给目标元素绑定点击事件回调`callback01`，在回调内部实现添加遮罩层容器和克隆元素的动画效果，完成预览功能
  4.给遮罩层容绑定点击事件回调`callback02`，在回调内部实现立场效果和移除遮罩层容器，完成点击取消预览功能
##### 完善
  5.在模块中声明变量`global`，作用是保存`callback02`函数，给window绑定scroll和resize事件，触发就执行`callback02`完成取消预览功能。
  6.基于步骤3，在点击目标元素的事件回调中，通过预览的唯一性，将`global`的值赋值为`callback02`，在window的scroll和resize事件时就能够成功触发取消预览功能。
  7.基于步骤4，在取消预览时，需要重置`global`为`null`，保证取消预览后再触发给window绑定scroll和resize事件时不会调用`global`函数。
##### 动画实现
  1.(克隆元素的起始位置):在点击目标元素时，克隆元素需要从目标元素的位置移动到视口中间位置。所以在点击时通过`getBoundingClientRect`来获取**目标元素基于视口左上角的位置信息**（`top`、`left`，视口左上角距离目标元素左上角的距离）,这个偏移量正是遮罩层距离初始位置的克隆元素的偏移量（因为遮罩层就是视口大小，而遮罩层设置了fixed定位），**为了后续css的实现，所以将这两个变量通过style.setProperty保存在克隆元素(遮罩层也行，只要保证css变量能够访问，css变量是继承的)中**
  2.(动画实现):由于top、left起始值保存了，由于克隆元素需要基于绝对定位来实现，所以需要将克隆元素设置为绝对定位，在样式文件中定义克隆元素的动画。而为了动画能够成功设置所以定义了进场和离场两个class，完成复用动画。
  ```css
.enter {
  animation: .3s 1 toMove forwards;
}

.leave {
  animation: .3s 1 toMove forwards reverse;
}

@keyframes toMove {
  from {
    top: var(--top);
    left: var(--left);
  }

  to {
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
  }
}
  ```
  3.(绑定动画):在出场时添加enter进场动画，动画结束后删除，在取消预览时先添加leave离场动画，动画结束后删除，就大功告成了。
#### 使用方式
```vue
<template>
  <div class="list">
    <img src="@/imgs/01.png" v-element>
    <img src="@/imgs/01.png" v-element>
    <img src="@/imgs/01.png" v-element>
  </div>
</template>

<script lang='ts' setup>
import element from './components/element';
defineOptions({
  directives: {
    element
  }
})
</script>

<style scoped lang='scss'>
.list {
  display: flex;
  flex-direction: column;
  padding: 100px;
  align-items: center;
  height: 500vh;
  img {
    cursor: pointer;
    width: 300px;
    margin-bottom: 10px;
  }
}
</style>
```
#### 代码
#### css
```css
.mask-container {
  position: fixed;
  background-color: #00000079;
  inset: 0;
  z-index: 999;
  display: flex;
  align-items: center;
  justify-content: center;
}

.enter {
  animation: .3s 1 toMove forwards;
}

.leave {
  animation: .3s 1 toMove forwards reverse;
}

@keyframes toMove {
  from {
    top: var(--top);
    left: var(--left);
  }

  to {
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
  }
}
```
##### js
```ts
import type { Directive } from 'vue';
import './index.css'

// 取消预览的事件回调 
// 因为同一时间预览只会预览一个，所以只需要保存这一个回调即可，滚动条事件触发就执行回调
let handle: null | Function = null
window.addEventListener('scroll', () => {
  handle && handle()
})
window.addEventListener('resize', () => {
  handle && handle()
})


export default {
  /**
   * 1.深拷贝目标元素，做为预览
   * 2.创建遮罩层作为预览时的容器，将元素放到遮罩层中去
   * 3.给目标元素绑定点击事件，点击显示容器，并通过css隐藏自身
   * 4.给遮罩层绑定点击事件，点击时移除容器
   * 5.通过预览时的唯一性，来保存一个移除时的回调，在滚动事件和拉伸事件时取消预览
   * @param el 
   */
  mounted (el) {

    // 克隆当前元素
    const elCopy = el.cloneNode(true) as HTMLElement
    // 遮罩层
    const maskContainer = document.createElement('div')
    maskContainer.classList.add('mask-container')
    // 创建遮罩层，让元素成为为遮罩层的子元素
    maskContainer.appendChild(elCopy)


    // 点击遮罩层取消预览的事件回调
    const onHandleClick = (e?: Event) => {
      if (e && e.target === elCopy) {
        // 若时点击的目标元素，停止冒泡
        return
      }
      // 执行时将全局的置空(重要)
      handle = null
      // 添加离场动画
      elCopy.classList.add('leave')
      setTimeout(() => {
        // 动画执行完后移除立场动画
        elCopy.classList.remove('leave')
        maskContainer.remove()
        el.style.visibility = 'visible'
      }, 300)
    }

    // 点击遮罩层取消预览,恢复目标元素的样式
    maskContainer.addEventListener('click', onHandleClick)

    // 点击事件的回调 并隐藏当前元素
    el.addEventListener('click', () => {
      // 将点击遮罩层取消预览的事件保存到全局
      handle = onHandleClick
      // 获取目标元素距离视口的位置
      const { top, left } = el.getBoundingClientRect()
      // 给容器（给克隆元素也行）挂载当前元素距离视口位置的属性 (最关键的地方)
      maskContainer.style.setProperty('--top', `${ top }px`)
      maskContainer.style.setProperty('--left', `${ left }px`)
      // 设置子元素的绝对定位，配合动画
      elCopy.style.position = 'absolute'
      // 给子元素加入入场动画
      elCopy.classList.add('enter')
      setTimeout(() => {
        // 动画结束后删除入场动画
        elCopy.classList.remove('enter')
      }, 300)
      el.style.visibility = 'hidden'
      document.body.appendChild(maskContainer)
    })

  }
} as Directive<HTMLElement, undefined>

```

### 十三、vite项目配置别名的情况下在js中访问assets静态资源

```ts
/**

 * 获取静态资源
 * @param path 从assets根路径开始
   */
   export function getAssets (path:string) {
     return new URL(`../../assets/${path}`,import.meta.url).href
   }
   使用：
   const navList = [
     {
   title: 'Home',
   activeIconName: getAssets('icon/footer/home_active.png'),
   iconName: getAssets('icon/footer/home.png'),
   path: '/',
     },
     {
   title: 'Subscribe',
   activeIconName: getAssets('icon/footer/subscribe_active.png'),
   iconName: getAssets('icon/footer/subscribe.png'),
   path: '/subscribe',
     },
     {
   title: 'My',
   activeIconName: getAssets('icon/footer/my_active.png'),
   iconName: getAssets('icon/footer/my.png'),
   path: '/my',
     }
   ]
```

### 十四、vite启动不同环境下的项目

​	在项目启动时，我们可以让项目以什么环境下启动，例如开发环境、生成环境下启动。

#### 配置package.json文件

```json
  "scripts": {
    "start:dev": "vite --mode development", // 开发模式
    "start:pro": "vite --mode production", // 生产模式
    "build": "vue-tsc && vite build",
    "preview": "vite preview"
  },
```

注意development、production，这两个模式下一定要有对应环境变量文件

创建.env.development和.env.production环境变量文件，并定义环境变量

#### 自定义模式

```json
  "scripts": {
    "start:dev": "vite --mode development",
    "start:pro": "vite --mode production",
    "start:test":"vite --mode testok", // 自定义模式
    "build": "vue-tsc && vite build",
    "preview": "vite preview"
  },
```

模式名称为testok，则我们必须保证工程里面有.env.testok文件即可。

### 十五、TS给window对象扩展属性

​	当我们想给项目挂载一个全局API时，尝尝都是把他挂载到window上去，这样我们就可以随时随地的调用。在js里只需要获取到window然后给他添加一个属性即可。但是在ts中由于Window的类型定义不包含我们自定义属性，所以需要额外的扩展声明。

​	在项目中创建types文件，并创建index.d.ts文件

```ts
import type { MessageApi } from 'naive-ui'
export { };

declare global {
  interface Window {
    /**
     * naive-ui的消息组件api
     */
    $message: MessageApi
  }
}
```

### 十六、css字体描边

```css
  h2 {
        -webkit-text-stroke:1px #fff;
      }
```

### 十七、音频播放与系统媒体控制

在播放网页音乐时`mediaSession`可以帮助你将浏览器当前播放的音乐在通知栏中显示，例如手机端可以在播放音乐时在通知栏中控制音乐的播放与查看音乐信息，pc端可以通过浏览器来控制音乐的播放与查看音乐信息。

#### 例子

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <audio src="./郑钧 - 私奔.mp3"></audio>
    <button>播放</button>
    <script>
      const audio = document.querySelector('audio')
      const btn = document.querySelector('button')

      if ('mediaSession' in navigator) {
        // 音频元数据，浏览器会将歌曲显示展示在操作系统的通知栏中。
        navigator.mediaSession.metadata = new MediaMetadata({
          title: '私奔',
          artist: '郑钧',
          album: '私奔',
          artwork: [
            {
              src: 'https://dummyimage.com/96x96',
              sizes: '96x96',
              type: 'image/png'
            },
            {
              src: 'https://dummyimage.com/128x128',
              sizes: '128x128',
              type: 'image/png'
            },
            {
              src: 'https://dummyimage.com/192x192',
              sizes: '192x192',
              type: 'image/png'
            },
            {
              src: 'https://dummyimage.com/256x256',
              sizes: '256x256',
              type: 'image/png'
            },
            {
              src: 'https://dummyimage.com/384x384',
              sizes: '384x384',
              type: 'image/png'
            },
            {
              src: 'https://dummyimage.com/512x512',
              sizes: '512x512',
              type: 'image/png'
            }
          ]
        })
        // 当通过操作系统点击播放时
        navigator.mediaSession.setActionHandler('play', function () {
          handleClick()
          navigator.mediaSession.playbackState = 'playing'
        })
        // 当通过操作系统点击暂停时
        navigator.mediaSession.setActionHandler('pause', function () {
          handleClick()
          navigator.mediaSession.playbackState = 'paused'
        })
      }
      // 点击播放或暂停
      const handleClick = () => {
        if (audio.paused) {
          audio.play()
          btn.innerText = '播放'
        } else {
          audio.pause()
          btn.innerText = '暂停'
        }
      }
      btn.addEventListener('click', handleClick)
    </script>
  </body>
</html>

```

#### 文档

https://zhuanlan.zhihu.com/p/157888134

https://developer.mozilla.org/zh-CN/docs/Web/API/MediaSession

https://runebook.dev/zh/docs/dom/mediasession

### 十八、浏览器调用输入输出接口

`navigator.mediaDevices`可以通过浏览器调用媒体设备

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <button onclick="getUserDevices()">获取摄像头和麦克风</button>
    <button onclick="getDisplayDevices()">获取显示器和扬声器权限</button>
    <video></video>
    <script>
      const video = document.querySelector('video')
      // getUserMedia获取输出设备
      async function getUserDevices() {
        if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {
          console.log(await navigator.mediaDevices.getSupportedConstraints())
          try {
            const data = await navigator.mediaDevices.getUserMedia({
              // 获取输入设备-麦克风 的调用权限
              audio: true,
              // 获取输入设备-摄像头 的调用权限
              video: true
            })
            video.srcObject = data
            video.onloadedmetadata = () => {
              video.play()
            }
          } catch (error) {
            console.log('拒绝了调用请求.')
          }
        } else {
          Promise.race('浏览器不支持调用设备接口!')
        }
      }
      // getDisplayMedia获取输入设备
      async function getDisplayDevices() {
        if (navigator.mediaDevices && navigator.mediaDevices.getDisplayMedia) {
          try {
            const data = await navigator.mediaDevices.getDisplayMedia({
              // 获取输出设备-扬声器 的调用权限
              audio: true,
              // 获取输出设备-显示器 的调用权限
              video: true
            })
            video.srcObject = data
            video.onloadedmetadata = () => {
              video.play()
            }
          } catch (error) {
            console.log('拒绝了调用请求.')
          }
        } else {
          Promise.race('浏览器不支持调用设备接口!')
        }
      }
    </script>
  </body>
</html>

```

#### 将文件流合并成二进制文件

要将 `srcObject` 的媒体流数据上传到服务端并保存为视频文件，你需要先将媒体流数据转换为视频文件的格式，然后将该文件上传到服务器。以下是一般的步骤：

1. 在客户端，使用 `MediaRecorder` API 将 `srcObject` 的媒体流数据录制为视频文件。`MediaRecorder` 提供了对媒体流进行录制的功能。你可以设置录制的输出格式和编解码器等参数。

   示例代码如下：

   ```
   const mediaRecorder = new MediaRecorder(srcObject);
   const chunks = [];
   
   mediaRecorder.ondataavailable = (event) => {
     chunks.push(event.data);
   };
   
   mediaRecorder.onstop = () => {
     const blob = new Blob(chunks, { type: 'video/webm' });
     // 将 blob 上传到服务器或进行其他操作
   };
   
   mediaRecorder.start();
   // 一定要调用mediaRecorder.start()，否则ondataavailable事件不会触发!!
   /* 录制一段时间后调用 mediaRecorder.stop() 停止录制并触发 onstop 事件 */
   ```

   

2. 将录制的媒体数据存储为一个 Blob 对象。通过在 `ondataavailable` 事件中收集录制的数据块，最后将它们合并为一个 Blob 对象。

3. 通过Ajax请求发送给后端。

#### 停止浏览器调用输入输出设备

通过调用`mediaStream.getTracks().forEach(track => track.stop())`方法停止浏览器调用输入输出设备。

`mediaStream.getTracks()`方法将返回一个`MediaStreamTrack`对象的数组，表示当前`MediaStream`中的所有轨道（音频轨道和视频轨道）。通过遍历这个数组，并调用每个轨道的`stop()`方法，你可以停止浏览器调用输入输出设备。

在你的代码中，你可以在停止录制后的`recordData.stop()`之后添加以下代码：

```javascript
mediaStream.getTracks().forEach(track => track.stop());
```

这将停止浏览器调用输入输出设备，释放资源。

### 十九、常用的响应体类型

 表格如下：

| **MIME-Typ**                                                | **Dateiendung(en)**             | **Bedeutung**                                                |
| ----------------------------------------------------------- | ------------------------------- | ------------------------------------------------------------ |
| A[Bearbeiten]                                               |                                 |                                                              |
| application/acad                                            | *.dwg                           | AutoCAD-Dateien (nach NCSA)                                  |
| application/applefile                                       |                                 | AppleFile-Dateien                                            |
| application/astound                                         | *.asd *.asn                     | Astound-Dateien                                              |
| application/dsptype                                         | *.tsp                           | TSP-Dateien                                                  |
| application/dxf                                             | *.dxf                           | AutoCAD-Dateien (nach CERN)                                  |
| application/futuresplash                                    | *.spl                           | Flash Futuresplash-Dateien                                   |
| application/gzip                                            | *.gz                            | GNU Zip-Dateien                                              |
| application/javascript                                      | *.js                            | serverseitige JavaScript-Dateien                             |
| application/json                                            | *.json                          | enthält einen String in JavaScript-Objekt-Notation           |
| application/listenup                                        | *.ptlk                          | Listenup-Dateien                                             |
| application/mac-binhex40                                    | *.hqx                           | Macintosh Binärdateien                                       |
| application/mbedlet                                         | *.mbd                           | Mbedlet-Dateien                                              |
| application/mif                                             | *.mif                           | FrameMaker Interchange Format Dateien                        |
| application/msexcel                                         | *.xls *.xla                     | Microsoft Excel Dateien                                      |
| application/mshelp                                          | *.hlp *.chm                     | Microsoft Windows Hilfe Dateien                              |
| application/mspowerpoint                                    | *.ppt *.ppz *.pps *.pot         | Microsoft Powerpoint Dateien                                 |
| application/msword                                          | *.doc *.dot                     | Microsoft Word Dateien                                       |
| application/octet-stream                                    | *.bin *.exe *.com *.dll *.class | Nicht näher spezifizierte Daten, z.B. ausführbare Dateien    |
| application/oda                                             | *.oda                           | Oda-Dateien                                                  |
| application/pdf                                             | *.pdf                           | PDF-Dateien                                                  |
| application/postscript                                      | *.ai *.eps *.ps                 | PostScript-Dateien                                           |
| application/rtc                                             | *.rtc                           | RTC-Dateien                                                  |
| application/rtf                                             | *.rtf                           | RTF-Dateien                                                  |
| application/studiom                                         | *.smp                           | Studiom-Dateien                                              |
| application/toolbook                                        | *.tbk                           | Toolbook-Dateien                                             |
| application/vocaltec-media-desc                             | *.vmd                           | Vocaltec Mediadesc-Dateien                                   |
| application/vocaltec-media-file                             | *.vmf                           | Vocaltec Media-Dateien                                       |
| application/                                                | *.xlsx                          | Excel (OpenOffice Calc)                                      |
| vnd.openxmlformats-officedocument. spreadsheetml.sheet      |                                 |                                                              |
| application/                                                | *.docx                          | Word (OpenOffice Writer)                                     |
| vnd.openxmlformats-officedocument.wordprocessingml.document |                                 |                                                              |
| application/xhtml+xml                                       | *.htm *.html *.shtml *.xhtml    | XHTML-Dateien                                                |
| application/xml                                             | *.xml                           | XML-Dateien                                                  |
| application/x-bcpio                                         | *.bcpio                         | BCPIO-Dateien                                                |
| application/x-compress                                      | *.z                             | zlib-komprimierte Dateien                                    |
| application/x-cpio                                          | *.cpio                          | CPIO-Dateien                                                 |
| application/x-csh                                           | *.csh                           | C-Shellscript-Dateien                                        |
| application/x-director                                      | *.dcr *.dir *.dxr               | Macromedia Director-Dateien                                  |
| application/x-dvi                                           | *.dvi                           | DVI-Dateien                                                  |
| application/x-envoy                                         | *.evy                           | Envoy-Dateien                                                |
| application/x-gtar                                          | *.gtar                          | GNU tar-Archivdateien                                        |
| application/x-hdf                                           | *.hdf                           | HDF-Dateien                                                  |
| application/x-httpd-php                                     | *.php *.phtml                   | PHP-Dateien                                                  |
| application/x-latex                                         | *.latex                         | LaTeX-Quelldateien                                           |
| application/x-macbinary                                     | *.bin                           | Macintosh Binärdateien                                       |
| application/x-mif                                           | *.mif                           | FrameMaker Interchange Format Dateien                        |
| application/x-netcdf                                        | *.nc *.cdf                      | Unidata CDF-Dateien                                          |
| application/x-nschat                                        | *.nsc                           | NS Chat-Dateien                                              |
| application/x-sh                                            | *.sh                            | Bourne Shellscript-Dateien                                   |
| application/x-shar                                          | *.shar                          | Shell-Archivdateien                                          |
| application/x-shockwave-flash                               | *.swf *.cab                     | Flash Shockwave-Dateien                                      |
| application/x-sprite                                        | *.spr *.sprite                  | Sprite-Dateien                                               |
| application/x-stuffit                                       | *.sit                           | Stuffit-Dateien                                              |
| application/x-supercard                                     | *.sca                           | Supercard-Dateien                                            |
| application/x-sv4cpio                                       | *.sv4cpio                       | CPIO-Dateien                                                 |
| application/x-sv4crc                                        | *.sv4crc                        | CPIO-Dateien mit CRC                                         |
| application/x-tar                                           | *.tar                           | tar-Archivdateien                                            |
| application/x-tcl                                           | *.tcl                           | TCL Scriptdateien                                            |
| application/x-tex                                           | *.tex                           | TeX-Dateien                                                  |
| application/x-texinfo                                       | *.texinfo *.texi                | Texinfo-Dateien                                              |
| application/x-troff                                         | *.t *.tr *.roff                 | TROFF-Dateien (Unix)                                         |
| application/x-troff-man                                     | *.man *.troff                   | TROFF-Dateien mit MAN-Makros (Unix)                          |
| application/x-troff-me                                      | *.me *.troff                    | TROFF-Dateien mit ME-Makros (Unix)                           |
| application/x-troff-ms                                      | *.me *.troff                    | TROFF-Dateien mit MS-Makros (Unix)                           |
| application/x-ustar                                         | *.ustar                         | tar-Archivdateien (Posix)                                    |
| application/x-wais-source                                   | *.src                           | WAIS Quelldateien                                            |
| application/x-www-form-urlencoded                           |                                 | HTML-Formulardaten an CGI                                    |
| application/zip                                             | *.zip                           | ZIP-Archivdateien                                            |
| audio/basic                                                 | *.au *.snd                      | Sound-Dateien                                                |
| audio/echospeech                                            | *.es                            | Echospeed-Dateien                                            |
| audio/tsplayer                                              | *.tsi                           | TS-Player-Dateien                                            |
| audio/voxware                                               | *.vox                           | Vox-Dateien                                                  |
| audio/x-aiff                                                | *.aif *.aiff *.aifc             | AIFF-Sound-Dateien                                           |
| audio/x-dspeeh                                              | *.dus *.cht                     | Sprachdateien                                                |
| audio/x-midi                                                | *.mid *.midi                    | MIDI-Dateien                                                 |
| audio/x-mpeg                                                | *.mp2                           | MPEG-Audiodateien                                            |
| audio/x-pn-realaudio                                        | *.ram *.ra                      | RealAudio-Dateien                                            |
| audio/x-pn-realaudio-plugin                                 | *.rpm                           | RealAudio-Plugin-Dateien                                     |
| audio/x-qt-stream                                           | *.stream                        | Quicktime-Streaming-Dateien                                  |
| audio/x-wav                                                 | *.wav                           | WAV-Dateien                                                  |
|                                                             |                                 |                                                              |
| D[Bearbeiten]                                               |                                 |                                                              |
| drawing/x-dwf                                               | *.dwf                           | Drawing-Dateien                                              |
|                                                             |                                 |                                                              |
| I[Bearbeiten]                                               |                                 |                                                              |
| image/cis-cod                                               | *.cod                           | CIS-Cod-Dateien                                              |
| image/cmu-raster                                            | *.ras                           | CMU-Raster-Dateien                                           |
| image/fif                                                   | *.fif                           | FIF-Dateien                                                  |
| image/gif                                                   | *.gif                           | GIF-Dateien                                                  |
| image/ief                                                   | *.ief                           | IEF-Dateien                                                  |
| image/jpeg                                                  | *.jpeg *.jpg *.jpe              | JPEG-Dateien                                                 |
| image/png                                                   | *.png                           | PNG-Dateien                                                  |
| image/tiff                                                  | *.tiff *.tif                    | TIFF-Dateien                                                 |
| image/vasa                                                  | *.mcf                           | Vasa-Dateien                                                 |
| image/vnd.wap.wbmp                                          | *.wbmp                          | Bitmap-Dateien (WAP)                                         |
| image/x-freehand                                            | *.fh4 *.fh5 *.fhc               | Freehand-Dateien                                             |
| image/x-icon                                                | *.ico                           | Icon-Dateien (z.B. Favoriten-Icons)                          |
| image/x-portable-anymap                                     | *.pnm                           | PBM Anymap Dateien                                           |
| image/x-portable-bitmap                                     | *.pbm                           | PBM Bitmap Dateien                                           |
| image/x-portable-graymap                                    | *.pgm                           | PBM Graymap Dateien                                          |
| image/x-portable-pixmap                                     | *.ppm                           | PBM Pixmap Dateien                                           |
| image/x-rgb                                                 | *.rgb                           | RGB-Dateien                                                  |
| image/x-windowdump                                          | *.xwd                           | X-Windows Dump                                               |
| image/x-xbitmap                                             | *.xbm                           | XBM-Dateien                                                  |
| image/x-xpixmap                                             | *.xpm                           | XPM-Dateien                                                  |
|                                                             |                                 |                                                              |
| M[Bearbeiten]                                               |                                 |                                                              |
| message/external-body                                       |                                 | Nachricht mit externem Inhalt                                |
| message/http                                                |                                 | HTTP-Headernachricht                                         |
| message/news                                                |                                 | Newsgroup-Nachricht                                          |
| message/partial                                             |                                 | Nachricht mit Teilinhalt                                     |
| message/rfc822                                              |                                 | Nachricht nach RFC (2)822                                    |
| model/vrml                                                  | *.wrl                           | Visualisierung virtueller Welten (VRML)                      |
| multipart/alternative                                       |                                 | mehrteilige Daten; jeder Teil ist eine zu den anderen gleichwertige Alternative |
| multipart/byteranges                                        |                                 | mehrteilige Daten mit Byte-Angaben                           |
| multipart/digest                                            |                                 | mehrteilige Daten / Auswahl                                  |
| multipart/encrypted                                         |                                 | mehrteilige Daten verschlüsselt                              |
| multipart/form-data                                         |                                 | mehrteilige Daten aus HTML-Formular (z.B. File-Upload)       |
| multipart/mixed                                             |                                 | mehrteilige Daten ohne Bezug der Teile untereinander         |
| multipart/parallel                                          |                                 | mehrteilige Daten parallel                                   |
| multipart/related                                           |                                 | mehrteilige Daten mit Abhängigkeiten der Teile voneinander   |
| multipart/report                                            |                                 | mehrteilige Daten / Bericht                                  |
| multipart/signed                                            |                                 | mehrteilige Daten / bezeichnet                               |
| multipart/voice-message                                     |                                 | mehrteilige Daten / Sprachnachricht                          |
|                                                             |                                 |                                                              |
| T[Bearbeiten]                                               |                                 |                                                              |
| text/comma-separated-values                                 | *.csv                           | kommaseparierte Datendateien                                 |
| text/css                                                    | *.css                           | CSS Stylesheet-Dateien                                       |
| text/html                                                   | *.htm *.html *.shtml            | HTML-Dateien                                                 |
| text/javascript                                             | *.js                            | JavaScript-Dateien                                           |
| text/plain                                                  | *.txt                           | reine Textdateien                                            |
| text/richtext                                               | *.rtx                           | Richtext-Dateien                                             |
| text/rtf                                                    | *.rtf                           | RTF-Dateien                                                  |
| text/tab-separated-values                                   | *.tsv                           | tabulator-separierte Datendateien                            |
| text/vnd.wap.wml                                            | *.wml                           | WML-Dateien (WAP)                                            |
| application/vnd.wap.wmlc                                    | *.wmlc                          | WMLC-Dateien (WAP)                                           |
| text/vnd.wap.wmlscript                                      | *.wmls                          | WML-Scriptdateien (WAP)                                      |
| application/vnd.wap.wmlscriptc                              | *.wmlsc                         | WML-Script-C-dateien (WAP)                                   |
| text/xml                                                    | *.xml                           | XML-Dateien                                                  |
| text/xml-external-parsed-entity                             |                                 | extern geparste XML-Dateien                                  |
| text/x-setext                                               | *.etx                           | SeText-Dateien                                               |
| text/x-sgml                                                 | *.sgm *.sgml                    | SGML-Dateien                                                 |
| text/x-speech                                               | *.talk *.spc                    | Speech-Dateien                                               |
|                                                             |                                 |                                                              |
| V[Bearbeiten]                                               |                                 |                                                              |
| video/mpeg                                                  | *.mpeg *.mpg *.mpe              | MPEG-Videodateien                                            |
| video/quicktime                                             | *.qt *.mov                      | Quicktime-Dateien                                            |
| video/vnd.vivo                                              | *.viv *.vivo                    | Vivo-Dateien                                                 |
| video/x-msvideo                                             | *.avi                           | Microsoft AVI-Dateien                                        |
| video/x-sgi-movie                                           | *.movie                         | Movie-Dateien                                                |
|                                                             |                                 |                                                              |
| W[Bearbeiten]                                               |                                 |                                                              |
| workbook/formulaone                                         | *.vts *.vtts                    | FormulaOne-Dateien                                           |
|                                                             |                                 |                                                              |
| X[Bearbeiten]                                               |                                 |                                                              |
| x-world/x-3dmf                                              | *.3dmf *.3dm *.qd3d *.qd3       | 3DMF-Dateien                                                 |
| x-world/x-vrml                                              | *.wrl                           | Visualisierung virtueller Welten (VRML) (veralteter MIME-Typ, aktuell ist model/vrml) |

### 20、字符与unicode编码互相转换

#### 字符转unicode

charCodeAt可以输出字符对应的unicode编码

```js
"你".charCodeAt(0).toString("16") // 转换成16进制
"你".charCodeAt(0) // 十进制
```

#### unicode转字符

String.fromCharCode静态方法可以将unicode编码转换成字符串

```js
 String.fromCharCode(0x4f60)
```



### 21、下载文件进度

​	在网页中，有文件下载功能时，我们时长需要通过文件总大小以及当前下载大小计算出下载百分比。但纯前端无法获得目标文件的总大小，此时我们需要让后端的响应报文中配置响应头部`Content-Length`字段，Content-Length字段可以和XHR配合，更好的实现下载进度这个功能。

#### 后端

​	后端需要在响应数据的同时配置`Content-Length`字段即可，在node中可以通过`fs.stat`获取文件信息。文件读取最好使用流式+管道的方式，这样节省内存开销和带宽占用。

```js
  // 返回文件大小
  res.setHeader("Content-Length", String(stats.size));
```

#### 前端

​	通过XHR实例的onprogress事件，监听传输过程

​	e.total是本次传输的总大小，后端必须响应Content-Length字段，否则一致都是0。

```js
const box = document.querySelector(".box");
const xhr = new XMLHttpRequest();
xhr.open("get", "/01.mp4");
xhr.send();
xhr.onprogress = (e) => {
    // e.loaded是当前加载了多少了
    // e.total是总大小，后端必须响应Content-Length字段，否则一直都是0
    box.innerText = `${((e.loaded / e.total) * 100).toFixed(2)}%`;
};
xhr.onload = (e) => {
    console.log(e);
};
```



### 22、SSE和EventStream

https://juejin.cn/post/7229632570374783034#heading-14

​	SSE既是服务端发送消息，是一种轻量级长连接协议，和websocket不同，socket可以双端接受发送消息，而SSE只能由服务端发送消息,并且SSE自动会重连.

从“服务端主动向浏览器实时推送消息”这一点来看，该 API 与 WebSockets API 有一些相似之处。但是，该 API 与 WebSockers API 的不同之处在于：

| Server-Sent Events API                          | WebSockets API                 |
| ----------------------------------------------- | ------------------------------ |
| 基于 HTTP 协议                                  | 基于 TCP 协议                  |
| 单工，只能服务端单向发送消息                    | 全双工，可以同时发送和接收消息 |
| 轻量级，使用简单                                | 相对复杂                       |
| 内置断线重连和消息追踪的功能                    | 不在协议范围内，需手动实现     |
| 文本或使用 Base64 编码和 gzip 压缩的二进制消息  | 类型广泛                       |
| 支持**自定义**事件类型                          | 不支持自定义事件类型           |
| 连接数 HTTP/1.1 6 个，HTTP/2 可协商（默认 100） | 连接数无限制                   |

​	服务器发送事件（SSE）受到打开连接数的限制，这个限制是*对于浏览器*的，并且设置为非常低的数字（6），打开多个选项卡时可能会特别痛苦。

​	SSE应用场景：ChatGPT.

ChatGPT这种需要耗费大量时间计算才能得到最终结果,不适用与Ajax,因为Ajax只能一次请求响应一次结果,也就是说要想得到完整数据,就必须等待GPT把全部的计算完成才能返回,中间可能会耗费很多时间.

#### SSE浏览器上使用

使用浏览器提供的`EventSource`来完成SSE通信,简单易用.通过`addEventListener`来实现自定义事件的监听,回调可以接受一个参数,这个参数就是服务端响应的数据.

`EventSource`内置了三种事件：

`open` ：连接成功就触发

`error` :出错或关闭时触发

`message`:服务端响应的SSE报文数据中event字段为`message`或无evetn字段就触发该事件回调。

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <h1>你好</h1>
    <button>开启连接</button>
    <button>断开连接</button>
    <div class="list"></div>
    <script>
      const [start, end] = document.getElementsByTagName('button')
      const list = end.nextElementSibling

      let eventSource = null

      const startSSE = () => {
        eventSource = new EventSource('/stream')
        eventSource.addEventListener('customEvent', (event) => {
          console.log(event);
          const li = document.createElement('li')
          li.innerText = JSON.stringify(event.data)
          list.append(li)
        })
        eventSource.onopen = () => {
          console.log('SSE连接成功!')
        }
        eventSource.onerror = () => {
          console.log('SSE连接失败!')
        }
      }

      const closeSSE = () => {
        if (eventSource) {
          eventSource.close()
          console.log('关闭连接!')
        }
      }

      start.onclick = startSSE
      end.onclick = closeSSE
    </script>
  </body>
</html>

```





#### SSE服务端上使用

##### SSE的响应头部的设置

​	首先SSE协议的报文必须要设置的响应头部为`content-type` `cache-control` `connection`

```
Content-Type: text/event-stream
Cache-Control: no-cache
Connection: keep-alive
```

> SSE API规定推送事件流的 MIME 类型为 `text/event-stream`。
>
> 必须指定浏览器不缓存服务端发送的数据，以确保浏览器可以实时显示服务端发送的数据。
>
> SSE 是一个一直保持开启的 TCP 连接，所以 Connection 为 keep-alive。

##### SSE报文消息格式

EventStream（事件流）为 `UTF-8` 格式编码的`文本`或使用 Base64 编码和 gzip 压缩的二进制消息。

​	每条消息由一行或多行字段（`event`、`id`、`retry`、`data`）组成，每个字段组成形式为：`字段名:字段值`。字段以行为单位，每行一个（即以 `\n` 结尾）。以`冒号`开头的行为注释行，会被浏览器忽略。

​	每次推送，可由多个消息组成，每个消息之间以空行分隔（即最后一个字段以`\n\n`结尾）。

> 📢 注意：
>
> - 除上述四个字段外，其他所有字段都会被忽略。
> - 如果一行字段中不包含冒号，则整行文本将被视为字段名，字段值为空。
> - 注释行可以用来防止链接超时，服务端可以定期向浏览器发送一条消息注释行，以保持连接不断。

###### 1. event

​	事件类型。如果指定了该字段，则在浏览器收到该条消息时，会在当前 `EventSource` 对象（见 4）上触发一个事件，事件类型就是该字段的字段值。可以使用 `addEventListener` 方法在当前 `EventSource` 对象上监听任意类型的命名事件。

​	如果该条消息没有 `event` 字段，则会触发 `EventSource` 对象 `onmessage` 属性上的事件处理函数。如果接收消息中有一个 event 字段，触发的事件与 event 字段的值相同。如果不存在 event 字段，则将触发通用的 [`message`](https://developer.mozilla.org/zh-CN/docs/Web/API/EventSource/message_event) 事件

###### 2. id

​	事件ID。事件的唯一标识符，浏览器会跟踪事件ID，如果发生断连，浏览器会把收到的最后一个事件ID放到 HTTP Header `Last-Event-Id` 中进行重连，作为一种简单的同步机制。

​	例如可以在服务端将每次发送的事件ID值自动加 1，当浏览器接收到该事件ID后，下次与服务端建立连接后再请求的 Header 中将同时提交该事件ID，服务端检查该事件ID是否为上次发送的事件ID，如果与上次发送的事件ID不一致则说明浏览器存在与服务器连接失败的情况，本次需要同时发送前几次浏览器未接收到的数据。

###### 3. retry

​	重连时间。整数值，单位 ms，如果与服务器的连接丢失，浏览器将等待指定时间，然后尝试重新连接。如果该字段不是整数值，会被忽略。

​	当服务端没有指定浏览器的重连时间时，由浏览器自行决定每隔多久与服务端建立一次连接（一般为 30s）。

###### 4. data

​	消息数据。数据内容只能以一个字符串的文本形式进行发送，如果需要发送一个对象时，需要将该对象以一个 JSON 格式的字符串的形式进行发送。在浏览器接收到该字符串后，再把它还原为一个 JSON 对象。

##### SSE报文示例

​	如下事件流示例，共发送了 4 条消息，每条消息间以一个空行`\n\n`作为分隔符。

​	第一条仅仅是个注释，因为它以冒号开头。

​	第二条消息只包含一个 data 字段，值为 'this is second message'。

​	第三条消息包含两个 data 字段，其会被解析为一个字段，值为 'this is third message part 1\nthis is third message part 2'。

​	第四条消息包含完整四个字段，指定了事件类型为 'server-time'，事件id 为 '1'，重连时间为 '30000'ms，消息数据为 `JSON` 格式的 '{"text": "this is fourth message", "time": "12:00:00"}'。

```js
: this is first message\n\n

data: this is second message\n\n

data: this is third message part one\n
data this is third message part two\n\n

event: server-time\n
id: 1
retry: 30000\n
data: {"text": "this is fourth message", "time": "2023-04-09 12:00:00"}\n\n
```



##### 代码

```js
function getStream(req, res) {
  res.setHeader('Content-type', 'text/event-stream') // 开启sse协议
  res.setHeader('Cache-Control', 'no-cache') // 避免浏览器缓存
  res.setHeader('Connection', 'keep-alive') // sse是一个一直保持开启的 TCP 连接，所以 Connection 为 keep-alive
  let id = 1
  // 当请求断开时，结束响应
  req.on('close', () => {
    id = 0
    clearInterval(timer)
    res.end()
  })
  const timer = setInterval(() => {
    // 自定义事件名称customEvent
    res.write(`event: customEvent\n`)
    res.write(`id: ${id}\n`)
    res.write(`retry: 30000\n`)
    res.write(`data: ${JSON.stringify({content:'你好!'})}\n\n`)
    id++
    // 响应10次内容就结束本次HTTP传输
    if (id >= 10) {
      clearInterval(timer)
      res.end()
    }
  }, 1000)
}
```

### 23.判断浏览器是处于PC端还是PE端

#### 一、navigator.userAgent

最简单的方法就是分析浏览器的 user agent 字符串，它包含了设备信息。

JS 通过`navigator.userAgent`属性拿到这个字符串，只要里面包含`mobi`、`android`、`iphone`等关键字，就可以认定是移动设备。

> ```javascript
> if (/Mobi|Android|iPhone/i.test(navigator.userAgent)) {
>   // 当前设备是移动设备
> }
> 
> // 另一种写法
> if (
>   navigator.userAgent.match(/Mobi/i) ||
>   navigator.userAgent.match(/Android/i) ||
>   navigator.userAgent.match(/iPhone/i)
> ) {
>   // 当前设备是移动设备
> }
> ```

这种方法的优点是简单方便，缺点是不可靠，因为用户可以修改这个字符串，让手机浏览器伪装成桌面浏览器。

Chromium 系的浏览器，还有一个`navigator.userAgentData`属性，也是类似的作用。不同之处是它将 user agent 字符串解析为一个对象，该对象的`mobile`属性，返回一个布尔值，表示用户是否使用移动设备。

> ```javascript
> const isMobile = navigator.userAgentData.mobile; 
> ```

注意，苹果的 Safari 浏览器和 Firefox 浏览器都不支持这个属性，具体情况可以查看 [Caniuse 网站](https://caniuse.com/mdn-api_navigator_useragentdata)。

此外，还有一个已经废除的[`navigator.platform`属性](https://stackoverflow.com/questions/19877924/what-is-the-list-of-possible-values-for-navigator-platform-as-of-today)，所有浏览器都支持，所以也可以用。它返回一个字符串，表示用户的操作系统。

> ```javascript
> if (/Android|iPhone|iPad|iPod/i.test(navigator.platform)) {
>   // 当前设备是移动设备
> }
> ```

#### 二、window.screen，window.innerWidth

另一种方法是通过屏幕宽度，判断是否为手机。

`window.screen`对象返回用户设备的屏幕信息，该对象的`width`属性是屏幕宽度（单位为像素）。

> ```javascript
> if (window.screen.width < 500) {
>   // 当前设备是移动设备 
> }
> ```

上面示例中，如果屏幕宽度`window.screen.width`小于500像素，就认为是手机。

这个方法的缺点在于，如果手机横屏使用，就识别不了。

另一个属性`window.innerWidth`返回浏览器窗口里面的网页可见部分的宽度，比较适合指定网页在不同宽度下的样式。

> ```javascript
> const getBrowserWidth = function() {
>   if (window.innerWidth < 768) {
>     return "xs";
>   } else if (window.innerWidth < 991) {
>     return "sm";
>   } else if (window.innerWidth < 1199) {
>     return "md";
>   } else {
>     return "lg";
>   }
> };
> ```

#### 三、window.orientation

第三种方法是侦测屏幕方向，手机屏幕可以随时改变方向（横屏或竖屏），桌面设备做不到。

`window.orientation`属性用于获取屏幕的当前方向，只有移动设备才有这个属性，桌面设备会返回`undefined`。

> ```javascript
> if (typeof window.orientation !== 'undefined') {
>   // 当前设备是移动设备 
> }
> ```

注意，iPhone 的 Safari 浏览器不支持该属性。

#### 四、touch 事件

第四种方法是，手机浏览器的 DOM 元素可以通过`ontouchstart`属性，为`touch`事件指定监听函数。桌面设备没有这个属性。

> ```javascript
> function isMobile() { 
>   return ('ontouchstart' in document.documentElement); 
> }
> 
> // 另一种写法
> function isMobile() {
>   try {
>     document.createEvent("TouchEvent"); return true;
>   } catch(e) {
>     return false; 
>   }
> }
> ```

#### 五、window.matchMedia()

最后一种方法是结合 CSS 来判断。

CSS 通过 media query（媒介查询）为网页指定响应式样式。如果某个针对手机的 media query 语句生效了，就可以认为当前设备是移动设备。

`window.matchMedia()`方法接受一个 CSS 的 media query 语句作为参数，判断这个语句是否生效。

> ```javascript
> let isMobile = window.matchMedia("only screen and (max-width: 760px)").matches;
> ```

上面示例中，`window.matchMedia()`的参数是一个 CSS 查询语句，表示只对屏幕宽度不超过 700 像素的设备生效。它返回一个对象，该对象的`matches`属性是一个布尔值。如果是`true`，就表示查询生效，当前设备是手机。

除了通过屏幕宽度判断，还可以通过指针的精确性判断。

> ```javascript
> let isMobile = window.matchMedia("(pointer:coarse)").matches;
> ```

上面示例中，CSS 语句`pointer:coarse`表示当前设备的指针是不精确的。由于手机不支持鼠标，只支持触摸，所以符合这个条件。

有些设备支持多种指针，比如同时支持鼠标和触摸。`pointer:coarse`只用来判断主指针，此外还有一个`any-pointer`命令判断所有指针。

> ```javascript
> let isMobile = window.matchMedia("(any-pointer:coarse)").matches;
> ```

上面示例中，`any-pointer:coarse`表示所有指针里面，只要有一个指针是不精确的，就符合查询条件。

### 24.Web Worker

​	`web worker`是浏览器独有的API，可以为`javascript`创建多个线程。只允许主线程创建`Web Worker`，可以让`Web Worker`执行一些后台任务。可以通过`Web Worker`创建子线程执行一些操作，例如耗费大量时间的同步操作（但不会阻塞主线程运行）、发送网络请求....有了`Web Worker`可以避免同步操作阻塞主线程渲染的问题。

​	由于创建了多个线程，为了不影响主线程，所以`Web Worker`有以下限制：

（1）**同源限制**

​	分配给 Worker 线程运行的脚本文件，必须与主线程的脚本文件同源。

（2）**DOM 限制**

​	Worker 线程所在的全局对象，与主线程不一样，无法读取主线程所在网页的 DOM 对象，也无法使用`document`、`window`、`parent`这些对象。但是，Worker 线程可以`navigator`对象和`location`对象。

（3）**通信联系**

​	**Worker 线程**和**主线程**不在同一个上下文环境，它们不能直接通信，必须通过消息完成主线程和子线程的通信。

（4）**脚本限制**

​	Worker 线程不能执行`alert()`方法和`confirm()`方法，但可以使用 XMLHttpRequest 对象发出 AJAX 请求。

（5）**文件限制**

​	Worker 线程无法读取本地文件，即不能打开本机的文件系统（`file://`），它所加载的脚本，必须来自网络。



#### 1.主线程

​	主线程通过`new Worker`来创建一个子线程，`Worker`构造函数必须是HTTP协议，必须加载网络脚本资源。返回一个worker实例，可以和对应子线程通信。

```js
new Worker('/index.js')  // 发送请求加载外部脚本资源，并将该资源放在子线程中执行
```

​	**通信**：

1.主线程通过`worker.postMessage`向对应的子线程发送消息

2.主线程通过`worker`的`message`监听子线程发送的消息

3.主线程通过`worker.terminate`结束子线程。

```js
      const wb = new Worker('index.js')
      // 接受子线程消息
      wb.onmessage = (data) => {
        console.log('接受子线程消息:' + data.data)
        console.log(window.a);
      }
      setTimeout(() => {
        // 向对应子线程发送消息
        wb.postMessage('hello~')
      }, 1000)
```

#### 2.子线程

​	子线程里失去了很多API，不过浏览器也为子线程提供了内置API。在子线程中是不能操作DOM，并且子线程和主线程的执行上下文是不同的，所以不能共享声明的变量、函数等。

​	**通信**:

1.子线程通过`this.postMessage`与发送消息给主线程

2.子线程通过`this.addEventListen("message")`来监听主线程发送的消息。

3.子线程通过`this.close`关闭线程，释放内存

```js
this.addEventListener('message', (data) => {
  console.log('接受到主线程消息:' + data.data)
})

this.postMessage('子线程消息~~')

```

#### 3.使用Web Worker的示例

​	同步计算复杂数据时，会阻塞浏览器渲染线程，从而导致页面**卡死**。若我们使用`Web Worker`就不会产生这样的后果。

​	1.不使用Web Worker（Sync）

```html
  <button>执行一段长时间阻塞主线程的代码</button>
    <input />
    <script>
      const btn = document.querySelector('button')

      function fun(time) {
        const now = Date.now()
        while (Date.now() - now <= time) {}
      }

      btn.onclick = () => {
        // 渲染进程卡死
        fun(2000)
      }
    </script>	
```

​	2.使用Web Worker

​	主线程代码：

```js
   function webworker() {
       // 执行复杂的同步任务
        const worker = new Worker('01.js')
        worker.onmessage=(e)=>{
          console.log(e.data);
          worker.terminate()
        }
      }
```

​	子线程代码：

```js
console.log('Work Load!')

fun(2000)
this.postMessage('计算完成~')
this.close()
function fun(time) {
  const now = Date.now()
  while (Date.now() - now <= time) {}
}

```

