### 一、var

#### 案例1

​	说说下列输出结果

```js
function outer() {
  var a = 5
  function inner() {
    console.log(a)
    var a = 10
    console.log(a)
  }
  return inner
}
outer()()

```
我的结果:
```shell
5
10
```
答案：
```shell
undefined
10
```

为啥？其实就是因为var声明的变量会提升，并且由于父子作用域有同名变量优先使用子作用域的变量，所以才会出现undefined。

上述结果等同于:

```ts
function outer() {
  var a = 5
  function inner() {
    var a
    console.log(a)
    a = 10
    console.log(a)
  }
  return inner
}
outer()()

```

就是因为a变量被提升到inner作用域的顶部了，outter作用域和inner作用域有相同名称变量时，使用inner作用域的a，所以就会打印undefined。

### 二、异步任务

#### 1.案例1（循环+setTimeout）

下列结果

```ts
var j = 0;
for(let i = 0; i < 2; i++,j++) {
    setTimeout(function timer(){
        console.log(i,j)
    })
}
```

我的答案

```shell
2 2
2 2
```

结果

```shell
0 2
1 2
```



原因:

​	原因就是let有块级作用域，而var循环没有作用域的原因，且因为for循环每次都会创建一个块级作用域以及对应的迭代器（i、j..）。

​	有下列三种情况：

##### 1.在for中初始化迭代器let

​	若在for初始化时用let声明的变量，就会**因为块级作用域而导致let声明的变量只会在当前块级作用域下生效**。而setTimeout中的回调函数会在同步任务完成时，到主线程中执行，执行时通过闭包访问到迭代时产生的作用域中的i。

```ts
for (let i = 0; i < 2; i++) {
  setTimeout(function timer() {
    console.log(i) // 0 1
  })
}
```

##### 2.在for中初始化迭代器var

​	若迭代器是var声明的就会因为**无块级作用域导致所有的块级作用域访问的是同一个变量**，而由于同步异步的问题，for循环同步完成后，才会执行异步任务setTimeout。

```ts
// 异步任务和同步任务导致的，同步循环执行完了才执行回调
for (var i = 0; i < 2; i++) {
  setTimeout(function timer() {
    console.log(i) // 2 2
  })
}
```



##### 3.在外部for外部声明的迭代器

​	若迭代器是来自外部作用域，则所有迭代器产生的块级作用域都通过作用域链访问的同一个变量。

```ts
// let
let i = 0
for (; i < 2; i++){
  setTimeout(() => {
    console.log(2);
  })
}

// var
var i = 0
for (; i < 2; i++) {
  setTimeout(() => {
    console.log(2)
  })
}
```



##### let示例

```js
for (let i = 0; i < 2; i++) {
  // 每次for循环都是一个独立的块级作用域，保存着i的值，timer通过闭包访问到i
  setTimeout(function timer() {
    console.log(i)
  })
}
// 等同于，每次for循环都声明了一个块级作用域，setTimeout通过闭包获取到块级作用域下的i，由于let
{
    let i=0
    setTimeout(()=>{
        console.log(i)
	})
}
{
    let i=1
    setTimeout(()=>{
        console.log(i)
	})
}
```

##### var示例

```ts
for (var i = 0; i < 2; i++) {
  setTimeout(function timer() {
    console.log(i) // 2 2
  })
}
// 等同于 
{
    var i=0
    setTimeout(()=>{
        console.log(i)
	})
}
{
    var i=1
    setTimeout(()=>{
        console.log(i)
	})
}
```

